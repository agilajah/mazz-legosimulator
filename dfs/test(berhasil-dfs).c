#pragma config(StandardModel, "EV3_REMBOT")
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//KAMUS GLOBAL
bool isBlueFound = false;
int x = 0; //as counter for text line on the brick
int jalur[50];
//HEADER
//
bool isRed();
bool isGreen();
bool isBlue();
bool isBlack();
bool isWhite();
//
void rotate180DegreesToRight();
void rotateRightUntilLineFound();
void goToNodeAndBack(bool* isNodeAvaible);
void moveUntilInitialNode();
void moveUntilEndNode();
void moveForwardABit();
void arrayInitialization();
void showTheRoute();
//
void findGateIn();
void findGateOut();



//MAIN
task main() {
	arrayInitialization();
	findGateIn();
	findGateOut();
	showTheRoute();
}



//IMPLEMENTASI HEADER
//

bool isRed() {
	int redRate, greenRate, blueRate;
	getColorRGB(colorSensor, redRate, greenRate, blueRate);
	delay(1);
	return ((redRate > greenRate) && (redRate > blueRate));
}

bool isGreen() {
	int redRate, greenRate, blueRate;
	getColorRGB(colorSensor, redRate, greenRate, blueRate);
	delay(1);
	return ((greenRate > redRate) && (greenRate > blueRate));
}

bool isBlue() {
	int redRate, greenRate, blueRate;
	getColorRGB(colorSensor, redRate, greenRate, blueRate);
	delay(1);
	return ((blueRate > greenRate) && (blueRate > redRate));
}

bool isBlack() {
	int redRate, greenRate, blueRate;
	getColorRGB(colorSensor, redRate, greenRate, blueRate);
	delay(1);
	return ((redRate == 0) && (greenRate == 0) && (blueRate == 0));
}

bool isWhite() {
	int redRate, greenRate, blueRate;
	getColorRGB(colorSensor, redRate, greenRate, blueRate);
	delay(1);
	return ((redRate == 100) && (greenRate == 100) && (blueRate == 100));
}


//
void rotate180DegreesToRight() {
  setMotorSpeed(leftMotor, 25);
  setMotorSpeed(rightMotor, -40);

  resetGyro(gyroSensor);
  delay(1);
  while (getGyroDegrees(gyroSensor) < 180) {
  	if (isBlack()) {
  		waitUntil(isWhite());
  	}
  }

  stopAllMotors();
}

void rotateRightUntilLineFound() {
	setMotorSpeed(leftMotor, 25);
  setMotorSpeed(rightMotor, -40);

  bool isFound = false;
  while (!isFound) {
  	if (isBlack()) {
  		waitUntil(isWhite());
  		isFound = true;
  	}
  }
	stopAllMotors();
}

/*
 *@param isNodeAvailable is input/output parameter
 */
void goToNodeAndBack(bool* isNodeAvaible) {
	moveUntilInitialNode();

	if (isRed()) {
		*isNodeAvaible = false;
	} else {
		*isNodeAvaible = true;
	}

	moveUntilEndNode();
	rotate180DegreesToRight();
	moveUntilInitialNode();
	moveUntilEndNode();
	rotate180DegreesToRight();
	stopAllMotors();
}

void moveUntilInitialNode() {
	while (!isRed() && !isGreen() && !isBlue()) {
		if (isWhite()) {
  		setMotorSpeed(leftMotor, 15);
 			setMotorSpeed(rightMotor, 55);
  	} else {
  		setMotorSpeed(leftMotor, 55);
  		setMotorSpeed(rightMotor, 15);
  	}
	}
	stopAllMotors();
}

void moveUntilEndNode() {
	resetTimer(timer1);
	while (getTimer(timer1, milliseconds) < 175) {
		if (!isRed() && !isGreen() && !isBlue()) {
 	  	setMotorSpeed(leftMotor, 15);
  		setMotorSpeed(rightMotor, 55);
 		} else {
 	  	setMotorSpeed(leftMotor, 55);
 			setMotorSpeed(rightMotor, 15);
 			resetTimer(timer1);
 		}
	}
	stopAllMotors();
}

void moveForwardABit() {
	setMotorSpeed(leftMotor, 25);
  setMotorSpeed(rightMotor, 25);
  delay(100);
  stopAllMotors();
}


//
void findGateIn() {
	while (!isBlue()) {
		setMotorSpeed(leftMotor, 15);
  	setMotorSpeed(rightMotor, 55);
  	resetTimer(timer1);
  	waitUntil((getTimer(timer1, milliseconds) >= 150) || (isBlue()));

  	setMotorSpeed(leftMotor, 55);
  	setMotorSpeed(rightMotor, 15);
  	resetTimer(timer1);
  	waitUntil((getTimer(timer1, milliseconds) >= 150) || (isBlue()));
	}
	moveForwardABit();

	while (!isBlack()) {
		if (!isBlue()) {
  		setMotorSpeed(leftMotor, 15);
 			setMotorSpeed(rightMotor, 55);
  	} else {
  		setMotorSpeed(leftMotor, 55);
  		setMotorSpeed(rightMotor, 15);
  	}
	}
	setMultipleMotors(25, leftMotor, rightMotor);
  delay(150);
	stopAllMotors();
}


//
void findGateOut() {
	int nNode = 0;
	bool isNodeAvaible[4] = {false, false, false, false};

	moveUntilInitialNode();

	if (isGreen()) {
		moveUntilEndNode();
		setMotorSpeed(leftMotor, 25);
  	setMotorSpeed(rightMotor, -40);
  	resetGyro(gyroSensor);
  	while (getGyroDegrees(gyroSensor) < 360) {
      if (isBlack()) {
  			waitUntil(isWhite());
  			++nNode;
  		}
  	}


  	rotate180DegreesToRight();

  	for (int i = 0; i < nNode-1; ++i) {
  		rotateRightUntilLineFound();
  		moveForwardABit();
  		goToNodeAndBack(&isNodeAvaible[i]);
  	}

  	rotateRightUntilLineFound();

  	bool isFinish = false;
  	int i = 0;
  	do {
  		rotateRightUntilLineFound();
  		if (isNodeAvaible[i]) {
  			moveForwardABit();
  			findGateOut();
  		}

  		if (i == nNode-1) {
  			isFinish = true;
  			for (int j = 0; j < nNode-1; ++j) {
  				if (isNodeAvaible[j]) {
  					isFinish = false;
  				}
  			}
  			i = 0;
  		} else {
  			++i;
  		}
  	}	while (!isBlueFound && !isFinish);
		//if Blue has been found
  	if (isBlueFound) {
  		do {
  			rotateRightUntilLineFound();
  			++i;
  		} while (i <= nNode-1);
  		//assign corresponding edge to the array element
  		jalur[x] = i-(nNode-1);
  		x++;
  	}

	} else /*if (isBlue())*/ {
		isBlueFound = true;
		moveUntilEndNode();
		rotate180DegreesToRight();
	}
  moveUntilInitialNode();
  moveUntilEndNode();
  rotate180DegreesToRight();
  moveForwardABit();
	stopAllMotors();
}

void arrayInitialization() {
	int i;
	for (i=0; i<50; i++) {
		jalur[i]=0;
	}
}

void showTheRoute() {
	/*//checking how much is the route
	int i=0;
	while (jalur[i]==0) {
		i++;
	}*/
	//the code above is no longer needed 'cause we can determine
	//how much edges are taken to reach the blue node from starting point

	//print the route to the brick
	int i, j;
	for (j=x; j>=0; j--) {
		displayTextLine(i+1, "Jalur yang diambil : %d ", jalur[j]);
		i++;
	}
}
